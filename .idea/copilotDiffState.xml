<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/ui/main_window.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/ui/main_window.py" />
              <option name="originalContent" value="from PySide6 import QtWidgets, QtCore&#10;import pyqtgraph as pg&#10;import numpy as np&#10;from scipy import signal&#10;import matplotlib.pyplot as plt&#10;&#10;class MainWindow(QtWidgets.QMainWindow):&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.setWindowTitle(&quot;Spectroscopic Analyzer&quot;)&#10;        self.resize(1200, 700)&#10;        self._setup_ui()&#10;&#10;    def _setup_ui(self):&#10;        # Central widget and main layout&#10;        central_widget = QtWidgets.QWidget()&#10;        self.setCentralWidget(central_widget)&#10;&#10;        # MAIN LAYOUT: Grid 2x2 (4 kuadran rata)&#10;        main_layout = QtWidgets.QGridLayout(central_widget)&#10;        main_layout.setContentsMargins(5, 5, 5, 5)&#10;        main_layout.setSpacing(10)&#10;&#10;        # ========== KUADRAN KIRI ATAS: PLOT UTAMA ==========&#10;        left_top_panel = QtWidgets.QWidget()&#10;        left_top_layout = QtWidgets.QVBoxLayout(left_top_panel)&#10;        left_top_layout.setContentsMargins(0, 0, 0, 0)&#10;&#10;        left_top_label = QtWidgets.QLabel(&quot; Full Spectrum - Drag Region Selector&quot;)&#10;        left_top_label.setStyleSheet(&quot;font-weight: bold; padding: 5px; background-color: #4a90e2; color: white;&quot;)&#10;        left_top_layout.addWidget(left_top_label)&#10;&#10;        self.plot_widget = pg.PlotWidget()&#10;        self.plot_widget.setLabel('left', 'Intensity', **{'font-size': '11pt'})&#10;        self.plot_widget.setLabel('bottom', 'Wavelength (nm)', **{'font-size': '11pt'})&#10;        self.plot_widget.showGrid(x=True, y=True)&#10;        left_top_layout.addWidget(self.plot_widget)&#10;&#10;        # ========== KUADRAN KANAN ATAS: PLOT PREVIEW ==========&#10;        right_top_panel = QtWidgets.QWidget()&#10;        right_top_layout = QtWidgets.QVBoxLayout(right_top_panel)&#10;        right_top_layout.setContentsMargins(0, 0, 0, 0)&#10;&#10;        # Header dengan tombol ekspor&#10;        right_top_header_layout = QtWidgets.QHBoxLayout()&#10;&#10;        right_top_label = QtWidgets.QLabel(&quot; Preview: Element Labels (Selected Region)&quot;)&#10;        right_top_label.setStyleSheet(&quot;font-weight: bold; padding: 5px; background-color: #50c878; color: white;&quot;)&#10;        right_top_header_layout.addWidget(right_top_label, 1)&#10;&#10;        btn_export_plot = QtWidgets.QPushButton(&quot; Export Scientific Plot&quot;)&#10;        btn_export_plot.setStyleSheet(&quot;font-weight: bold; padding: 3px 8px; background-color: #FFD700; color: black;&quot;)&#10;        btn_export_plot.setToolTip(&quot;Export the current plot as a publication-ready scientific figure&quot;)&#10;        right_top_header_layout.addWidget(btn_export_plot)&#10;&#10;        right_top_layout.addLayout(right_top_header_layout)&#10;&#10;        self.detail_plot_widget = pg.PlotWidget()&#10;        self.detail_plot_widget.setLabel('left', 'Intensity', **{'font-size': '11pt'})&#10;        self.detail_plot_widget.setLabel('bottom', 'Wavelength (nm)', **{'font-size': '11pt'})&#10;        self.detail_plot_widget.showGrid(x=True, y=True, alpha=0.3)&#10;        right_top_layout.addWidget(self.detail_plot_widget)&#10;&#10;        # ========== KUADRAN KIRI BAWAH: INPUT PARAMETER ==========&#10;        left_bottom_panel = QtWidgets.QWidget()&#10;        left_bottom_layout = QtWidgets.QVBoxLayout(left_bottom_panel)&#10;        left_bottom_layout.setContentsMargins(0, 0, 0, 0)&#10;&#10;        # Header&#10;        param_header = QtWidgets.QLabel(&quot;⚙️ Control Panel &amp; Parameters&quot;)&#10;        param_header.setStyleSheet(&quot;font-weight: bold; padding: 5px; background-color: #ff6b6b; color: white;&quot;)&#10;        left_bottom_layout.addWidget(param_header)&#10;&#10;        # Scroll area untuk parameters&#10;        param_scroll = QtWidgets.QScrollArea()&#10;        param_scroll.setWidgetResizable(True)&#10;        param_scroll.setFrameShape(QtWidgets.QFrame.Shape.NoFrame)&#10;&#10;        param_container = QtWidgets.QWidget()&#10;        param_container_layout = QtWidgets.QVBoxLayout(param_container)&#10;&#10;        # File operations group&#10;        file_group = QtWidgets.QGroupBox(&quot; File Operations&quot;)&#10;        file_group.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        file_layout = QtWidgets.QVBoxLayout(file_group)&#10;        btn_load_folder = QtWidgets.QPushButton(&quot; Load Folder&quot;)&#10;        btn_load = QtWidgets.QPushButton(&quot; Load File&quot;)&#10;        btn_save = QtWidgets.QPushButton(&quot; Save&quot;)&#10;        btn_export = QtWidgets.QPushButton(&quot; Export&quot;)&#10;        btn_preprocess = QtWidgets.QPushButton(&quot; Preprocess&quot;)&#10;        btn_predict = QtWidgets.QPushButton(&quot; Predict&quot;)&#10;&#10;        for btn in [btn_load_folder, btn_load, btn_save, btn_export, btn_preprocess, btn_predict]:&#10;            btn.setMinimumHeight(35)&#10;&#10;        file_layout.addWidget(btn_load_folder)&#10;        file_layout.addWidget(btn_load)&#10;        file_layout.addWidget(btn_save)&#10;        file_layout.addWidget(btn_export)&#10;        file_layout.addWidget(btn_preprocess)&#10;        file_layout.addWidget(btn_predict)&#10;        param_container_layout.addWidget(file_group)&#10;&#10;        # Baseline Correction group&#10;        baseline_group = QtWidgets.QGroupBox(&quot; Baseline Correction (ALS)&quot;)&#10;        baseline_group.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        baseline_layout = QtWidgets.QVBoxLayout(baseline_group)&#10;&#10;        baseline_label = QtWidgets.QLabel(&quot;ALS Lambda:&quot;)&#10;        baseline_input = QtWidgets.QLineEdit(&quot;100000&quot;)&#10;        baseline_input.setPlaceholderText(&quot;Regularization parameter&quot;)&#10;&#10;        intensity_label = QtWidgets.QLabel(&quot;Target Max Intensity:&quot;)&#10;        intensity_input = QtWidgets.QLineEdit(&quot;0.8&quot;)&#10;        intensity_input.setPlaceholderText(&quot;0.0 - 1.0&quot;)&#10;&#10;        anchor_label = QtWidgets.QLabel(&quot;ALS p:&quot;)&#10;        anchor_input = QtWidgets.QLineEdit(&quot;0.001&quot;)&#10;        anchor_input.setPlaceholderText(&quot;Asymmetry parameter (0-1)&quot;)&#10;&#10;        max_iter_label = QtWidgets.QLabel(&quot;ALS Max Iterations:&quot;)&#10;        max_iter_input = QtWidgets.QLineEdit(&quot;10&quot;)&#10;        max_iter_input.setPlaceholderText(&quot;Number of iterations&quot;)&#10;&#10;        baseline_layout.addWidget(baseline_label)&#10;        baseline_layout.addWidget(baseline_input)&#10;        baseline_layout.addWidget(intensity_label)&#10;        baseline_layout.addWidget(intensity_input)&#10;        baseline_layout.addWidget(anchor_label)&#10;        baseline_layout.addWidget(anchor_input)&#10;        baseline_layout.addWidget(max_iter_label)&#10;        baseline_layout.addWidget(max_iter_input)&#10;        param_container_layout.addWidget(baseline_group)&#10;&#10;        # Prediction Parameters group&#10;        prediction_group = QtWidgets.QGroupBox(&quot; Prediction Parameters&quot;)&#10;        prediction_group.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        prediction_layout = QtWidgets.QVBoxLayout(prediction_group)&#10;&#10;        threshold_label = QtWidgets.QLabel(&quot;Detection Threshold:&quot;)&#10;        threshold_input = QtWidgets.QLineEdit(&quot;0.4&quot;)&#10;        threshold_input.setPlaceholderText(&quot;0.0 - 1.0&quot;)&#10;&#10;        min_height_label = QtWidgets.QLabel(&quot;Min Peak Height:&quot;)&#10;        min_height_input = QtWidgets.QLineEdit(&quot;0.1&quot;)&#10;        min_height_input.setPlaceholderText(&quot;Minimum probability for peak&quot;)&#10;&#10;        min_width_label = QtWidgets.QLabel(&quot;Min Peak Width:&quot;)&#10;        min_width_input = QtWidgets.QLineEdit(&quot;1&quot;)&#10;        min_width_input.setPlaceholderText(&quot;Minimum width in data points&quot;)&#10;&#10;        max_peaks_label = QtWidgets.QLabel(&quot;Max Peaks per Element:&quot;)&#10;        max_peaks_input = QtWidgets.QLineEdit(&quot;3&quot;)&#10;        max_peaks_input.setPlaceholderText(&quot;Maximum number of peaks&quot;)&#10;&#10;        prominence_label = QtWidgets.QLabel(&quot;Peak Prominence:&quot;)&#10;        prominence_input = QtWidgets.QLineEdit(&quot;0.05&quot;)&#10;        prominence_input.setPlaceholderText(&quot;Minimum prominence&quot;)&#10;&#10;        min_distance_label = QtWidgets.QLabel(&quot;Min Peak Distance:&quot;)&#10;        min_distance_input = QtWidgets.QLineEdit(&quot;5&quot;)&#10;        min_distance_input.setPlaceholderText(&quot;Minimum distance between peaks&quot;)&#10;&#10;        self.threshold_input = threshold_input&#10;        self.min_height_input = min_height_input&#10;        self.min_width_input = min_width_input&#10;        self.max_peaks_input = max_peaks_input&#10;        self.prominence_input = prominence_input&#10;        self.min_distance_input = min_distance_input&#10;&#10;        prediction_layout.addWidget(threshold_label)&#10;        prediction_layout.addWidget(threshold_input)&#10;        prediction_layout.addWidget(min_height_label)&#10;        prediction_layout.addWidget(min_height_input)&#10;        prediction_layout.addWidget(min_width_label)&#10;        prediction_layout.addWidget(min_width_input)&#10;        prediction_layout.addWidget(max_peaks_label)&#10;        prediction_layout.addWidget(max_peaks_input)&#10;        prediction_layout.addWidget(prominence_label)&#10;        prediction_layout.addWidget(prominence_input)&#10;        prediction_layout.addWidget(min_distance_label)&#10;        prediction_layout.addWidget(min_distance_input)&#10;        param_container_layout.addWidget(prediction_group)&#10;&#10;        # Wavelength Range group&#10;        wavelength_group = QtWidgets.QGroupBox(&quot; Wavelength Range&quot;)&#10;        wavelength_group.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        wavelength_layout = QtWidgets.QVBoxLayout(wavelength_group)&#10;&#10;        min_wavelength_label = QtWidgets.QLabel(&quot;Min Wavelength (nm):&quot;)&#10;        min_wavelength_input = QtWidgets.QLineEdit(&quot;200&quot;)&#10;        min_wavelength_input.setPlaceholderText(&quot;Minimum wavelength&quot;)&#10;&#10;        max_wavelength_label = QtWidgets.QLabel(&quot;Max Wavelength (nm):&quot;)&#10;        max_wavelength_input = QtWidgets.QLineEdit(&quot;800&quot;)&#10;        max_wavelength_input.setPlaceholderText(&quot;Maximum wavelength&quot;)&#10;&#10;        self.min_wavelength_input = min_wavelength_input&#10;        self.max_wavelength_input = max_wavelength_input&#10;&#10;        wavelength_layout.addWidget(min_wavelength_label)&#10;        wavelength_layout.addWidget(min_wavelength_input)&#10;        wavelength_layout.addWidget(max_wavelength_label)&#10;        wavelength_layout.addWidget(max_wavelength_input)&#10;        param_container_layout.addWidget(wavelength_group)&#10;&#10;        # Results group&#10;        results_group = QtWidgets.QGroupBox(&quot;Results&quot;)&#10;        results_group.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        results_layout = QtWidgets.QVBoxLayout(results_group)&#10;        self.results_label = QtWidgets.QLabel(&quot;Results will appear here after prediction.&quot;)&#10;        results_layout.addWidget(self.results_label)&#10;        param_container_layout.addWidget(results_group)&#10;&#10;        param_container_layout.addStretch()&#10;        param_scroll.setWidget(param_container)&#10;        left_bottom_layout.addWidget(param_scroll)&#10;&#10;        # ========== KUADRAN KANAN BAWAH: FILE LIST &amp; LOG ==========&#10;        right_bottom_panel = QtWidgets.QWidget()&#10;        right_bottom_layout = QtWidgets.QVBoxLayout(right_bottom_panel)&#10;        right_bottom_layout.setContentsMargins(0, 0, 0, 0)&#10;&#10;        # Header&#10;        file_log_header = QtWidgets.QLabel(&quot; Files &amp; Log&quot;)&#10;        file_log_header.setStyleSheet(&quot;font-weight: bold; padding: 5px; background-color: #9b59b6; color: white;&quot;)&#10;        right_bottom_layout.addWidget(file_log_header)&#10;&#10;        # File list table&#10;        file_group_bottom = QtWidgets.QGroupBox(&quot; Loaded Files&quot;)&#10;        file_group_bottom.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        file_table_layout = QtWidgets.QVBoxLayout(file_group_bottom)&#10;&#10;        self.data_table = QtWidgets.QTableWidget(0, 3)&#10;        self.data_table.setHorizontalHeaderLabels([&quot;Filename&quot;, &quot;Intensity&quot;, &quot;Status&quot;])&#10;        self.data_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)&#10;        self.data_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)&#10;        self.data_table.horizontalHeader().setStretchLastSection(True)&#10;        file_table_layout.addWidget(self.data_table)&#10;        right_bottom_layout.addWidget(file_group_bottom, stretch=1)&#10;&#10;        # Log panel&#10;        log_group = QtWidgets.QGroupBox(&quot; Activity Log&quot;)&#10;        log_group.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        log_layout = QtWidgets.QVBoxLayout(log_group)&#10;&#10;        self.log_text = QtWidgets.QTextEdit()&#10;        self.log_text.setReadOnly(True)&#10;        self.log_text.setMaximumHeight(200)&#10;        self.log_text.setStyleSheet(&quot;background-color: #2c3e50; color: #ecf0f1; font-family: 'Courier New';&quot;)&#10;        log_layout.addWidget(self.log_text)&#10;        right_bottom_layout.addWidget(log_group, stretch=1)&#10;&#10;        # ========== ASSIGN KUADRAN KE GRID LAYOUT ==========&#10;        # Grid Layout: (row, col, rowSpan, colSpan)&#10;        main_layout.addWidget(left_top_panel, 0, 0)      # Kiri Atas&#10;        main_layout.addWidget(right_top_panel, 0, 1)     # Kanan Atas&#10;        main_layout.addWidget(left_bottom_panel, 1, 0)   # Kiri Bawah&#10;        main_layout.addWidget(right_bottom_panel, 1, 1)  # Kanan Bawah&#10;&#10;        # Set proporsi yang sama untuk semua kuadran&#10;        main_layout.setRowStretch(0, 1)&#10;        main_layout.setRowStretch(1, 1)&#10;        main_layout.setColumnStretch(0, 1)&#10;        main_layout.setColumnStretch(1, 1)&#10;&#10;        # Connect button signals&#10;        btn_load.clicked.connect(self.load_file)&#10;        btn_load_folder.clicked.connect(self.load_folder)&#10;        btn_preprocess.clicked.connect(self.preprocess_current_file)&#10;        btn_predict.clicked.connect(self.predict_current_file)&#10;        btn_export_plot.clicked.connect(self.export_publication_plot)&#10;        self.data_table.cellClicked.connect(self.on_file_selected)&#10;&#10;        # Menu bar&#10;        menu_bar = self.menuBar()&#10;        file_menu = menu_bar.addMenu(&quot;File&quot;)&#10;        file_menu.addAction(&quot;Open&quot;)&#10;        file_menu.addAction(&quot;Save&quot;)&#10;        file_menu.addSeparator()&#10;        file_menu.addAction(&quot;Exit&quot;, self.close)&#10;        view_menu = menu_bar.addMenu(&quot;View&quot;)&#10;        analysis_menu = menu_bar.addMenu(&quot;Analysis&quot;)&#10;        help_menu = menu_bar.addMenu(&quot;Help&quot;)&#10;        help_menu.addAction(&quot;About&quot;)&#10;&#10;        # Tool bar&#10;        tool_bar = self.addToolBar(&quot;Main Toolbar&quot;)&#10;        tool_bar.addAction(&quot;Load&quot;)&#10;        tool_bar.addAction(&quot;Save&quot;)&#10;        tool_bar.addAction(&quot;Start&quot;)&#10;        tool_bar.addAction(&quot;Stop&quot;)&#10;        self.min_wavelength_input.editingFinished.connect(self.update_region_from_inputs)&#10;        self.max_wavelength_input.editingFinished.connect(self.update_region_from_inputs)&#10;        tool_bar.addAction(&quot;Pan&quot;)&#10;        tool_bar.addAction(&quot;Reset&quot;)&#10;        tool_bar.addSeparator()&#10;        tool_bar.addAction(&quot;Export Plot&quot;)&#10;&#10;        # Status bar&#10;        self.statusBar().showMessage(&quot;Ready | Device: Disconnected | Mode: Idle&quot;)&#10;&#10;        # Initialize variables&#10;        self.loaded_folder = None&#10;        self.file_list = []&#10;        self.current_file = None&#10;        self.preprocessed_spectrum = None&#10;&#10;        # Parameter inputs&#10;        self.threshold_input = threshold_input&#10;        self.baseline_input = baseline_input&#10;        self.intensity_input = intensity_input&#10;        self.anchor_input = anchor_input&#10;        self.max_iter_input = max_iter_input&#10;        self.min_height_input = min_height_input&#10;        self.min_width_input = min_width_input&#10;        self.max_peaks_input = max_peaks_input&#10;        self.prominence_input = prominence_input&#10;        self.min_distance_input = min_distance_input&#10;&#10;        # Assets cache&#10;        self._assets_loaded = False&#10;        self._cached_model = None&#10;        self._cached_element_map = None&#10;        self._cached_target_wavelengths = None&#10;&#10;&#10;    # Helper: ensure assets are loaded once and valid&#10;    def ensure_assets_loaded(self) -&gt; bool:&#10;        &quot;&quot;&quot;Load and cache model/assets once. Returns True on success.&quot;&quot;&quot;&#10;        if self._assets_loaded:&#10;            return True&#10;        try:&#10;            from app.model import load_assets&#10;            assets = load_assets()&#10;            if not isinstance(assets, tuple) or len(assets) != 3:&#10;                self.log_text.append(&quot;load_assets() returned unexpected value — expected (model, element_map, wavelengths)&quot;)&#10;                return False&#10;            model, element_map, target_wavelengths = assets&#10;            # Basic validations&#10;            if not hasattr(model, '__call__'):&#10;                self.log_text.append(f&quot;Loaded model object is not callable: {type(model)}&quot;)&#10;                return False&#10;            if not isinstance(element_map, dict):&#10;                self.log_text.append(f&quot;element_map has unexpected type: {type(element_map)}&quot;)&#10;                return False&#10;            import numpy as _np&#10;            if not isinstance(target_wavelengths, _np.ndarray):&#10;                self.log_text.append(f&quot;target_wavelengths has unexpected type: {type(target_wavelengths)}&quot;)&#10;                return False&#10;&#10;            self._cached_model = model&#10;            self._cached_element_map = element_map&#10;            self._cached_target_wavelengths = target_wavelengths&#10;            self._assets_loaded = True&#10;            self.log_text.append(&quot;Aset model berhasil dimuat dan dicache.&quot;)&#10;            return True&#10;        except Exception as e:&#10;            import traceback&#10;            self.log_text.append(f&quot;Error loading assets: {e}&quot;)&#10;            self.log_text.append(traceback.format_exc())&#10;            return False&#10;&#10;    def load_file(self):&#10;        file_dialog = QtWidgets.QFileDialog(self, &quot;Open Data File&quot;, &quot;&quot;, &quot;Data Files (*.asc *.txt *.csv);;All Files (*)&quot;)&#10;        if file_dialog.exec():&#10;            file_path = file_dialog.selectedFiles()[0]&#10;            try:&#10;                with open(file_path, 'r') as f:&#10;                    content = f.read()&#10;                self.log_text.append(f&quot;Loaded file: {file_path}\n---\n{content[:1000]}\n---&quot;)&#10;            except Exception as e:&#10;                self.log_text.append(f&quot;Error loading file: {e}&quot;)&#10;&#10;    def load_folder(self):&#10;        folder = QtWidgets.QFileDialog.getExistingDirectory(self, &quot;Select Folder with ASC Files&quot;)&#10;        if folder:&#10;            import os&#10;            self.loaded_folder = folder&#10;            self.file_list = [f for f in os.listdir(folder) if f.lower().endswith('.asc')]&#10;            self.data_table.setRowCount(len(self.file_list))&#10;            for i, fname in enumerate(self.file_list):&#10;                self.data_table.setItem(i, 0, QtWidgets.QTableWidgetItem(fname))&#10;                self.data_table.setItem(i, 1, QtWidgets.QTableWidgetItem(&quot;-&quot;))&#10;                self.data_table.setItem(i, 2, QtWidgets.QTableWidgetItem(&quot;-&quot;))&#10;            self.log_text.append(f&quot;Loaded folder: {folder} ({len(self.file_list)} .asc files)&quot;)&#10;            if not self.file_list:&#10;                self.log_text.append(&quot;No .asc files found in the selected folder.&quot;)&#10;&#10;    def on_file_selected(self, row, col):&#10;        if not self.file_list or row &gt;= len(self.file_list):&#10;            self.log_text.append(&quot;No file selected or out of range.&quot;)&#10;            return&#10;        fname = self.file_list[row]&#10;        self.current_file = fname&#10;        import os&#10;        fpath = os.path.join(self.loaded_folder, fname)&#10;        try:&#10;            with open(fpath, 'r') as f:&#10;                lines = f.readlines()&#10;            # Parse ASC: cari dua kolom float&#10;            import numpy as np&#10;            data = []&#10;            for line in lines:&#10;                if line.strip() and not line.startswith('#'):&#10;                    parts = line.split()&#10;                    if len(parts) &gt;= 2:&#10;                        try:&#10;                            wl, inten = float(parts[0]), float(parts[1])&#10;                            data.append((wl, inten))&#10;                        except Exception:&#10;                            continue&#10;            if data:&#10;                arr = np.array(data)&#10;                self.plot_widget.clear()&#10;                self.plot_widget.plot(arr[:,0], arr[:,1], pen='b')&#10;                # Update kolom intensity (max) di tabel&#10;                max_inten = str(np.max(arr[:,1]))&#10;                self.data_table.setItem(row, 1, QtWidgets.QTableWidgetItem(max_inten))&#10;                self.log_text.append(f&quot;Plotted: {fname}&quot;)&#10;            else:&#10;                self.plot_widget.clear()&#10;                self.data_table.setItem(row, 1, QtWidgets.QTableWidgetItem(&quot;-&quot;))&#10;                self.log_text.append(f&quot;No valid data in: {fname}&quot;)&#10;        except Exception as e:&#10;            self.plot_widget.clear()&#10;            self.log_text.append(f&quot;Error reading {fname}: {e}&quot;)&#10;&#10;    def preprocess_current_file(self):&#10;        if not self.current_file or not self.loaded_folder:&#10;            self.log_text.append(&quot;No file selected for preprocessing.&quot;)&#10;            return&#10;        import os&#10;        import numpy as np&#10;        from app.processing import prepare_asc_data&#10;        try:&#10;            ok = self.ensure_assets_loaded()&#10;            if not ok:&#10;                self.log_text.append(&quot;Cannot preprocess because assets failed to load.&quot;)&#10;                return&#10;            model = self._cached_model&#10;            element_map = self._cached_element_map&#10;            target_wavelengths = self._cached_target_wavelengths&#10;        except Exception as e:&#10;            self.log_text.append(f&quot;Error loading assets: {e}&quot;)&#10;            return&#10;&#10;        fpath = os.path.join(self.loaded_folder, self.current_file)&#10;        try:&#10;            with open(fpath, 'r') as f:&#10;                content = f.read()&#10;            # Get parameters from inputs&#10;            try:&#10;                als_lambda = float(self.baseline_input.text())&#10;                target_max_intensity = float(self.intensity_input.text())&#10;                als_p = float(self.anchor_input.text())&#10;                als_max_iter = int(self.max_iter_input.text())&#10;            except ValueError:&#10;                self.log_text.append(&quot;Invalid input for ALS parameters. Using defaults.&quot;)&#10;                als_lambda = 1e5&#10;                target_max_intensity = 0.8&#10;                als_p = 0.001&#10;                als_max_iter = 10&#10;            self.preprocessed_spectrum = prepare_asc_data(content, target_wavelengths, target_max_intensity, als_lambda, als_p, als_max_iter)&#10;            self.plot_widget.clear()&#10;            self.plot_widget.plot(target_wavelengths, self.preprocessed_spectrum, pen='g')&#10;            # Update note di tabel&#10;            row = self.file_list.index(self.current_file)&#10;            self.data_table.setItem(row, 2, QtWidgets.QTableWidgetItem(&quot;Preprocessed&quot;))&#10;            self.log_text.append(f&quot;Preprocessed: {self.current_file}&quot;)&#10;        except Exception as e:&#10;            self.log_text.append(f&quot;Error preprocessing {self.current_file}: {e}&quot;)&#10;            import traceback&#10;            self.log_text.append(f&quot;Traceback: {traceback.format_exc()}&quot;)&#10;&#10;    def predict_current_file(self):&#10;        if self.preprocessed_spectrum is None:&#10;            self.log_text.append(&quot;No preprocessed spectrum to predict. Please preprocess first.&quot;)&#10;            return&#10;        try:&#10;            ok = self.ensure_assets_loaded()&#10;            if not ok:&#10;                self.log_text.append(&quot;Cannot predict because assets failed to load.&quot;)&#10;                return&#10;            model = self._cached_model&#10;            element_map = self._cached_element_map&#10;            target_wavelengths = self._cached_target_wavelengths&#10;&#10;            from app.model import predict_with_spatial_info&#10;&#10;            self.log_text.append(f&quot;Running prediction with spatial information...&quot;)&#10;&#10;            # Dapatkan prediksi global DAN spasial (per-wavelength)&#10;            global_pred, spatial_pred = predict_with_spatial_info(model, self.preprocessed_spectrum)&#10;&#10;            self.log_text.append(f&quot;Global prediction shape: {global_pred.shape}&quot;)&#10;            self.log_text.append(f&quot;Spatial prediction shape: {spatial_pred.shape}&quot;)&#10;            self.log_text.append(f&quot;Global pred range: [{global_pred.min():.3f}, {global_pred.max():.3f}]&quot;)&#10;&#10;            # Format hasil prediksi dengan nama elemen&#10;            element_names = list(element_map.keys())&#10;            result_text = &quot;Predicted Elements (probability &gt; 0.05):\n&quot;&#10;            result_text += &quot;=&quot; * 40 + &quot;\n&quot;&#10;            detected_elements = []&#10;&#10;            # Ambil semua elemen dengan threshold rendah&#10;            threshold = 0.05&#10;            for element, probability in zip(element_names, global_pred):&#10;                if probability &gt; threshold:&#10;                    detected_elements.append((element, float(probability)))&#10;&#10;            # Sort berdasarkan probability&#10;            detected_elements.sort(key=lambda x: x[1], reverse=True)&#10;&#10;            # Jika tidak ada yang terdeteksi, tampilkan top 10&#10;            if not detected_elements:&#10;                sorted_pred = sorted(zip(element_names, global_pred), key=lambda x: x[1], reverse=True)&#10;                result_text = &quot;Top 10 Predicted Elements:\n&quot;&#10;                result_text += &quot;=&quot; * 40 + &quot;\n&quot;&#10;                for element, probability in sorted_pred[:10]:&#10;                    result_text += f&quot;{element:&gt;6s}: {probability:.4f} ({probability*100:.2f}%)\n&quot;&#10;                    detected_elements.append((element, float(probability)))&#10;            else:&#10;                for element, probability in detected_elements:&#10;                    result_text += f&quot;{element:&gt;6s}: {probability:.4f} ({probability*100:.2f}%)\n&quot;&#10;&#10;            result_text += &quot;=&quot; * 40 + &quot;\n&quot;&#10;            result_text += f&quot;Total detected: {len(detected_elements)} elements&quot;&#10;&#10;            self.results_label.setText(result_text)&#10;            self.results_label.setWordWrap(True)&#10;&#10;            # Plot spektrum dengan label elemen MENGGUNAKAN SPATIAL PREDICTION&#10;            self.plot_spectrum_with_labels(&#10;                target_wavelengths,&#10;                self.preprocessed_spectrum,&#10;                detected_elements,&#10;                element_map,&#10;                spatial_pred  # Pass spatial prediction data&#10;            )&#10;&#10;            # Update note di tabel&#10;            if self.current_file in self.file_list:&#10;                row = self.file_list.index(self.current_file)&#10;                self.data_table.setItem(row, 2, QtWidgets.QTableWidgetItem(&quot;Predicted&quot;))&#10;&#10;            self.log_text.append(f&quot;✓ Prediction completed for: {self.current_file}&quot;)&#10;            self.log_text.append(f&quot;✓ Found {len(detected_elements)} potential elements&quot;)&#10;&#10;        except Exception as e:&#10;            self.log_text.append(f&quot;Error during prediction: {e}&quot;)&#10;            import traceback&#10;            self.log_text.append(f&quot;Traceback:\n{traceback.format_exc()}&quot;)&#10;&#10;    def plot_spectrum_with_labels(self, wavelengths, spectrum, detected_elements, element_map, spatial_pred=None):&#10;        &quot;&quot;&quot;Plot spektrum dengan region selector interaktif, label detail hanya di plot preview&quot;&quot;&quot;&#10;        if detected_elements is None or len(detected_elements) == 0:&#10;            self.log_text.append(&quot;No elements to label on spectrum&quot;)&#10;            return&#10;&#10;        try:&#10;            # Clear both plots&#10;            self.plot_widget.clear()&#10;            self.detail_plot_widget.clear()&#10;&#10;            # Warna untuk setiap elemen&#10;            colors = [&#10;                (255, 0, 0), (255, 102, 0), (255, 170, 0), (255, 215, 0), (0, 255, 0),&#10;                (0, 255, 255), (0, 136, 255), (0, 0, 255), (136, 0, 255), (255, 0, 255)&#10;            ]&#10;&#10;            element_names = list(element_map.keys())&#10;&#10;            if spatial_pred is not None:&#10;                self.log_text.append(&quot;Setting up interactive region selector...&quot;)&#10;&#10;                # Store data untuk digunakan saat region berubah&#10;                self.wavelengths = wavelengths&#10;                self.spectrum = spectrum&#10;                self.detected_elements = detected_elements&#10;                self.spatial_pred = spatial_pred&#10;                self.element_names = element_names&#10;                self.colors = colors&#10;&#10;                # ========== PLOT UTAMA: Spektrum + Region Selector (TANPA LABEL) ==========&#10;                self.plot_widget.plot(wavelengths, spectrum, pen=pg.mkPen(color=(100, 255, 100), width=2), name='Spectrum')&#10;&#10;                # Tambahkan LinearRegionItem untuk memilih region&#10;                # Default region: tengah spektrum ±100nm&#10;                wl_min, wl_max = wavelengths[0], wavelengths[-1]&#10;                wl_center = (wl_min + wl_max) / 2&#10;                # Try to use input values for initial region&#10;                try:&#10;                    input_min = float(self.min_wavelength_input.text())&#10;                    input_max = float(self.max_wavelength_input.text())&#10;                    if input_min &lt; input_max and wl_min &lt;= input_min &lt;= wl_max and wl_min &lt;= input_max &lt;= wl_max:&#10;                        initial_region = (input_min, input_max)&#10;                    else:&#10;                        initial_region = (wl_center - 50, wl_center + 50)&#10;                except ValueError:&#10;                    initial_region = (wl_center - 50, wl_center + 50)&#10;&#10;                self.region_selector = pg.LinearRegionItem(&#10;                    values=initial_region,&#10;                    brush=pg.mkBrush(100, 100, 200, 50),  # Semi-transparent blue&#10;                    pen=pg.mkPen(color=(100, 100, 255), width=2)&#10;                )&#10;                self.plot_widget.addItem(self.region_selector)&#10;&#10;                # Connect signal untuk update saat region berubah&#10;                self.region_selector.sigRegionChanged.connect(self.update_detail_plot)&#10;&#10;                # Setup main plot&#10;                self.plot_widget.setLabel('left', 'Normalized Intensity', **{'font-size': '12pt'})&#10;                self.plot_widget.setLabel('bottom', 'Wavelength (nm)', **{'font-size': '12pt'})&#10;                self.plot_widget.setTitle(&#10;                    'Full Spectrum (Drag the region selector to view details)',&#10;                    **{'font-size': '13pt', 'color': '#333'}&#10;                )&#10;                self.plot_widget.showGrid(x=True, y=True, alpha=0.3)&#10;&#10;                # Initial update untuk plot detail&#10;                self.update_detail_plot()&#10;&#10;                # Log info&#10;                self.log_text.append(f&quot;✓ Interactive region selector ready&quot;)&#10;                self.log_text.append(f&quot;✓ Drag the blue region on main plot to see details&quot;)&#10;                self.log_text.append(f&quot;✓ Detail plot will show labels for selected wavelength range&quot;)&#10;&#10;            else:&#10;                # Fallback&#10;                self.log_text.append(&quot;No spatial prediction available&quot;)&#10;                self.plot_widget.plot(wavelengths, spectrum, pen='g')&#10;                self.plot_widget.setTitle('Preprocessed Spectrum')&#10;&#10;        except Exception as e:&#10;            self.log_text.append(f&quot;Error plotting spectrum: {e}&quot;)&#10;            self.log_text.append(traceback.format_exc())&#10;&#10;    def update_detail_plot(self):&#10;        &quot;&quot;&quot;Update plot detail berdasarkan region yang dipilih di plot utama&quot;&quot;&quot;&#10;        try:&#10;            # Get peak parameters from inputs&#10;            try:&#10;                detection_threshold = float(self.threshold_input.text())&#10;                min_height = float(self.min_height_input.text())&#10;                min_width = float(self.min_width_input.text())&#10;                max_peaks = int(self.max_peaks_input.text())&#10;                prominence = float(self.prominence_input.text())&#10;                min_distance = float(self.min_distance_input.text())&#10;            except ValueError:&#10;                self.log_text.append(&quot;Invalid peak parameters. Using defaults.&quot;)&#10;                detection_threshold = 0.4&#10;                min_height = 0.1&#10;                min_width = 1&#10;                max_peaks = 3&#10;                prominence = 0.05&#10;                min_distance = 5&#10;&#10;            # Get selected region&#10;            region_range = self.region_selector.getRegion()&#10;            wl_start, wl_end = region_range&#10;&#10;            # Find indices dalam range&#10;            mask = (self.wavelengths &gt;= wl_start) &amp; (self.wavelengths &lt;= wl_end)&#10;            indices = np.where(mask)[0]&#10;&#10;            if len(indices) == 0:&#10;                return&#10;&#10;            # Extract data untuk region ini&#10;            wl_region = self.wavelengths[indices]&#10;            spectrum_region = self.spectrum[indices]&#10;            spatial_pred_region = self.spatial_pred[indices, :]&#10;&#10;            # Clear detail plot&#10;            self.detail_plot_widget.clear()&#10;&#10;            # Plot spektrum di region&#10;            self.detail_plot_widget.plot(&#10;                wl_region, spectrum_region,&#10;                pen=pg.mkPen(color=(100, 255, 100), width=2.5),&#10;                name='Spectrum'&#10;            )&#10;&#10;            # Untuk setiap wavelength di region, cek elemen yang terdeteksi&#10;            all_labels = []&#10;            for idx in range(len(wl_region)):&#10;                wl = wl_region[idx]&#10;                intensity = spectrum_region[idx]&#10;                labels_at_wl = []&#10;                for elem, global_prob in self.detected_elements[:10]:  # Batasi 10 elemen&#10;                    elem_idx = self.element_names.index(elem)&#10;                    prob = spatial_pred_region[idx, elem_idx]&#10;                    if prob &gt; detection_threshold:&#10;                        labels_at_wl.append((elem, prob, self.colors[self.element_names.index(elem) % len(self.colors)]))&#10;&#10;                if labels_at_wl:&#10;                    # Multilabel per titik&#10;                    primary_color = labels_at_wl[0][2] if len(labels_at_wl) == 1 else (128, 128, 128)&#10;&#10;                    # Marker&#10;                    scatter = pg.ScatterPlotItem(&#10;                        [wl], [intensity],&#10;                        pen=pg.mkPen(color=primary_color, width=2),&#10;                        brush=pg.mkBrush(*primary_color),&#10;                        size=10,  # Lebih kecil untuk banyak titik&#10;                        symbol='o'&#10;                    )&#10;                    self.detail_plot_widget.addItem(scatter)&#10;&#10;                    # Label&#10;                    label_parts = [f&quot;{elem}:{prob:.1%}&quot; for elem, prob, _ in labels_at_wl]&#10;                    text_label = &quot;\n&quot;.join(label_parts) + f&quot;\n{wl:.1f}nm&quot;&#10;&#10;                    text = pg.TextItem(&#10;                        text=text_label,&#10;                        color=primary_color,&#10;                        anchor=(0.5, 1.3),&#10;                        border=pg.mkPen(color=primary_color, width=1),&#10;                        fill=pg.mkBrush(0, 0, 0, 150)&#10;                    )&#10;                    text.setPos(wl, intensity)&#10;                    self.detail_plot_widget.addItem(text)&#10;&#10;                    # Vertical line (opsional, mungkin skip untuk banyak titik)&#10;                    # vline = pg.InfiniteLine(pos=wl, angle=90, pen=pg.mkPen(color=primary_color, width=1, style=QtCore.Qt.PenStyle.DotLine))&#10;                    # self.detail_plot_widget.addItem(vline)&#10;&#10;                    all_labels.append(f&quot;@{wl:.1f}nm: {', '.join([elem for elem, _, _ in labels_at_wl])}&quot;)&#10;&#10;            # Setup detail plot&#10;            self.detail_plot_widget.setLabel('left', 'Intensity', **{'font-size': '10pt'})&#10;            self.detail_plot_widget.setLabel('bottom', 'Wavelength (nm)', **{'font-size': '10pt'})&#10;            self.detail_plot_widget.setTitle(&#10;                f'Detail View ({wl_start:.1f} - {wl_end:.1f} nm) - {len(all_labels)} detections',&#10;                **{'font-size': '11pt'}&#10;            )&#10;            self.detail_plot_widget.showGrid(x=True, y=True, alpha=0.3)&#10;&#10;            # Auto-range untuk region yang dipilih&#10;            self.detail_plot_widget.setXRange(wl_start, wl_end, padding=0.02)&#10;&#10;        except Exception as e:&#10;            self.log_text.append(f&quot;Error updating detail plot: {e}&quot;)&#10;            import traceback&#10;            self.log_text.append(f&quot;Traceback:\n{traceback.format_exc()}&quot;)&#10;&#10;    def update_region_from_inputs(self):&#10;        &quot;&quot;&quot;Update the region selector based on min and max wavelength inputs&quot;&quot;&quot;&#10;        try:&#10;            min_wl = float(self.min_wavelength_input.text())&#10;            max_wl = float(self.max_wavelength_input.text())&#10;            if hasattr(self, 'region_selector'):&#10;                self.region_selector.setRegion((min_wl, max_wl))&#10;        except ValueError:&#10;            pass  # Ignore invalid input&#10;&#10;    def export_publication_plot(self):&#10;        &quot;&quot;&quot;Export the current detail plot (preview) with element labels as a publication-ready scientific figure&quot;&quot;&quot;&#10;        try:&#10;            # Check if we have spectrum data and region selector&#10;            if not hasattr(self, 'wavelengths') or not hasattr(self, 'spectrum') or not hasattr(self, 'region_selector'):&#10;                self.log_text.append(&quot;No spectrum data or region selector available for export. Please load, process a file, and select a region first.&quot;)&#10;                return&#10;&#10;            # Get current region&#10;            region_range = self.region_selector.getRegion()&#10;            wl_start, wl_end = region_range&#10;&#10;            # Find indices in range&#10;            mask = (self.wavelengths &gt;= wl_start) &amp; (self.wavelengths &lt;= wl_end)&#10;            indices = np.where(mask)[0]&#10;&#10;            if len(indices) == 0:&#10;                self.log_text.append(&quot;No data in selected region for export.&quot;)&#10;                return&#10;&#10;            # Extract data for region&#10;            wl_region = self.wavelengths[indices]&#10;            spectrum_region = self.spectrum[indices]&#10;            spatial_pred_region = self.spatial_pred[indices, :]&#10;&#10;            # Create matplotlib figure with publication style&#10;            plt.style.use('seaborn-v0_8-paper')  # Use a clean style&#10;            fig, ax = plt.subplots(figsize=(12, 8), dpi=300)&#10;&#10;            # Plot the spectrum region&#10;            ax.plot(wl_region, spectrum_region, color='black', linewidth=1.0)&#10;&#10;            # Get detection threshold&#10;            try:&#10;                detection_threshold = float(self.threshold_input.text())&#10;            except ValueError:&#10;                detection_threshold = 0.4&#10;&#10;            # Add detected elements annotations&#10;            colors = [&#10;                (255, 0, 0), (255, 102, 0), (255, 170, 0), (255, 215, 0), (0, 255, 0),&#10;                (0, 255, 255), (0, 136, 255), (0, 0, 255), (136, 0, 255), (255, 0, 255)&#10;            ]&#10;&#10;            element_annotations = []&#10;            for idx in range(len(wl_region)):&#10;                wl = wl_region[idx]&#10;                intensity = spectrum_region[idx]&#10;                labels_at_wl = []&#10;                for elem, global_prob in self.detected_elements[:10]:  # Limit to 10 elements&#10;                    elem_idx = self.element_names.index(elem)&#10;                    prob = spatial_pred_region[idx, elem_idx]&#10;                    if prob &gt; detection_threshold:&#10;                        labels_at_wl.append((elem, prob, colors[self.element_names.index(elem) % len(colors)]))&#10;&#10;                if labels_at_wl:&#10;                    # Use primary color for scatter&#10;                    primary_color = labels_at_wl[0][2]&#10;                    ax.scatter(wl, intensity, color=np.array(primary_color)/255, s=60, zorder=5, edgecolors='black', linewidth=0.5)&#10;&#10;                    # Create annotation text&#10;                    label_parts = [f&quot;{elem}:{prob:.1%}&quot; for elem, prob, _ in labels_at_wl]&#10;                    text_label = &quot;\n&quot;.join(label_parts) + f&quot;\n{wl:.1f}nm&quot;&#10;&#10;                    # Position annotation above the point&#10;                    ax.annotate(text_label,&#10;                              xy=(wl, intensity),&#10;                              xytext=(5, 20),&#10;                              textcoords='offset points',&#10;                              bbox=dict(boxstyle='round,pad=0.3', facecolor='white', alpha=0.9, edgecolor='gray'),&#10;                              fontsize=9, ha='left', va='bottom',&#10;                              arrowprops=dict(arrowstyle='-&gt;', color='gray', alpha=0.7))&#10;&#10;            # Customize plot for publication&#10;            ax.set_xlabel('Wavelength (nm)', fontsize=14, fontweight='bold')&#10;            ax.set_ylabel('Normalized Intensity', fontsize=14, fontweight='bold')&#10;            ax.grid(True, alpha=0.3)&#10;            ax.tick_params(axis='both', which='major', labelsize=12)&#10;            ax.set_xlim(wl_start, wl_end)&#10;&#10;            # Add file info&#10;            if self.current_file:&#10;                ax.text(0.02, 0.98, f'File: {self.current_file}\nRegion: {wl_start:.1f} - {wl_end:.1f} nm',&#10;                       transform=ax.transAxes, fontsize=10, verticalalignment='top',&#10;                       bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.7))&#10;&#10;            plt.tight_layout()&#10;&#10;            # Save dialog&#10;            file_path, _ = QtWidgets.QFileDialog.getSaveFileName(self, &quot;Save Publication Plot&quot;, &quot;&quot;, &quot;PNG Files (*.png);;PDF Files (*.pdf);;SVG Files (*.svg)&quot;)&#10;            if file_path:&#10;                import os&#10;                if os.path.isdir(file_path):&#10;                    self.log_text.append(&quot;Selected path is a directory. Please select a valid file name.&quot;)&#10;                    plt.close(fig)&#10;                    return&#10;                # Determine format from extension&#10;                if file_path.lower().endswith('.pdf'):&#10;                    plt.savefig(file_path, format='pdf', bbox_inches='tight', dpi=300)&#10;                elif file_path.lower().endswith('.svg'):&#10;                    plt.savefig(file_path, format='svg', bbox_inches='tight')&#10;                else:&#10;                    plt.savefig(file_path, format='png', bbox_inches='tight', dpi=300)&#10;&#10;                self.log_text.append(f&quot;✓ Publication plot exported to: {file_path}&quot;)&#10;            else:&#10;                self.log_text.append(&quot;Export cancelled.&quot;)&#10;&#10;            plt.close(fig)  # Close the figure to free memory&#10;&#10;        except Exception as e:&#10;            self.log_text.append(f&quot;Error exporting publication plot: {e}&quot;)&#10;            import traceback&#10;            self.log_text.append(f&quot;Traceback:\n{traceback.format_exc()}&quot;)&#10;" />
              <option name="updatedContent" value="from PySide6 import QtWidgets, QtCore&#10;import pyqtgraph as pg&#10;import numpy as np&#10;from scipy import signal&#10;import matplotlib.pyplot as plt&#10;&#10;class MainWindow(QtWidgets.QMainWindow):&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.setWindowTitle(&quot;Spectroscopic Analyzer&quot;)&#10;        self.resize(1200, 700)&#10;        self._setup_ui()&#10;&#10;    def _setup_ui(self):&#10;        # Central widget and main layout&#10;        central_widget = QtWidgets.QWidget()&#10;        self.setCentralWidget(central_widget)&#10;&#10;        # MAIN LAYOUT: Grid 2x2 (4 kuadran rata)&#10;        main_layout = QtWidgets.QGridLayout(central_widget)&#10;        main_layout.setContentsMargins(5, 5, 5, 5)&#10;        main_layout.setSpacing(10)&#10;&#10;        # ========== KUADRAN KIRI ATAS: PLOT UTAMA ==========&#10;        left_top_panel = QtWidgets.QWidget()&#10;        left_top_layout = QtWidgets.QVBoxLayout(left_top_panel)&#10;        left_top_layout.setContentsMargins(0, 0, 0, 0)&#10;&#10;        left_top_label = QtWidgets.QLabel(&quot; Full Spectrum - Drag Region Selector&quot;)&#10;        left_top_label.setStyleSheet(&quot;font-weight: bold; padding: 5px; background-color: #4a90e2; color: white;&quot;)&#10;        left_top_layout.addWidget(left_top_label)&#10;&#10;        self.plot_widget = pg.PlotWidget()&#10;        self.plot_widget.setLabel('left', 'Intensity', **{'font-size': '11pt'})&#10;        self.plot_widget.setLabel('bottom', 'Wavelength (nm)', **{'font-size': '11pt'})&#10;        self.plot_widget.showGrid(x=True, y=True)&#10;        left_top_layout.addWidget(self.plot_widget)&#10;&#10;        # ========== KUADRAN KANAN ATAS: PLOT PREVIEW ==========&#10;        right_top_panel = QtWidgets.QWidget()&#10;        right_top_layout = QtWidgets.QVBoxLayout(right_top_panel)&#10;        right_top_layout.setContentsMargins(0, 0, 0, 0)&#10;&#10;        # Header dengan tombol ekspor&#10;        right_top_header_layout = QtWidgets.QHBoxLayout()&#10;&#10;        right_top_label = QtWidgets.QLabel(&quot; Preview: Element Labels (Selected Region)&quot;)&#10;        right_top_label.setStyleSheet(&quot;font-weight: bold; padding: 5px; background-color: #50c878; color: white;&quot;)&#10;        right_top_header_layout.addWidget(right_top_label, 1)&#10;&#10;        btn_export_plot = QtWidgets.QPushButton(&quot; Export Scientific Plot&quot;)&#10;        btn_export_plot.setStyleSheet(&quot;font-weight: bold; padding: 3px 8px; background-color: #FFD700; color: black;&quot;)&#10;        btn_export_plot.setToolTip(&quot;Export the current plot as a publication-ready scientific figure&quot;)&#10;        right_top_header_layout.addWidget(btn_export_plot)&#10;&#10;        right_top_layout.addLayout(right_top_header_layout)&#10;&#10;        self.detail_plot_widget = pg.PlotWidget()&#10;        self.detail_plot_widget.setLabel('left', 'Intensity', **{'font-size': '11pt'})&#10;        self.detail_plot_widget.setLabel('bottom', 'Wavelength (nm)', **{'font-size': '11pt'})&#10;        self.detail_plot_widget.showGrid(x=True, y=True, alpha=0.3)&#10;        right_top_layout.addWidget(self.detail_plot_widget)&#10;&#10;        # ========== KUADRAN KIRI BAWAH: INPUT PARAMETER ==========&#10;        left_bottom_panel = QtWidgets.QWidget()&#10;        left_bottom_layout = QtWidgets.QVBoxLayout(left_bottom_panel)&#10;        left_bottom_layout.setContentsMargins(0, 0, 0, 0)&#10;&#10;        # Header&#10;        param_header = QtWidgets.QLabel(&quot;⚙️ Control Panel &amp; Parameters&quot;)&#10;        param_header.setStyleSheet(&quot;font-weight: bold; padding: 5px; background-color: #ff6b6b; color: white;&quot;)&#10;        left_bottom_layout.addWidget(param_header)&#10;&#10;        # Scroll area untuk parameters&#10;        param_scroll = QtWidgets.QScrollArea()&#10;        param_scroll.setWidgetResizable(True)&#10;        param_scroll.setFrameShape(QtWidgets.QFrame.Shape.NoFrame)&#10;&#10;        param_container = QtWidgets.QWidget()&#10;        param_container_layout = QtWidgets.QVBoxLayout(param_container)&#10;&#10;        # File operations group&#10;        file_group = QtWidgets.QGroupBox(&quot; File Operations&quot;)&#10;        file_group.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        file_layout = QtWidgets.QVBoxLayout(file_group)&#10;        btn_load_folder = QtWidgets.QPushButton(&quot; Load Folder&quot;)&#10;        btn_load = QtWidgets.QPushButton(&quot; Load File&quot;)&#10;        btn_save = QtWidgets.QPushButton(&quot; Save&quot;)&#10;        btn_export = QtWidgets.QPushButton(&quot; Export&quot;)&#10;        btn_preprocess = QtWidgets.QPushButton(&quot; Preprocess&quot;)&#10;        btn_predict = QtWidgets.QPushButton(&quot; Predict&quot;)&#10;&#10;        for btn in [btn_load_folder, btn_load, btn_save, btn_export, btn_preprocess, btn_predict]:&#10;            btn.setMinimumHeight(35)&#10;&#10;        file_layout.addWidget(btn_load_folder)&#10;        file_layout.addWidget(btn_load)&#10;        file_layout.addWidget(btn_save)&#10;        file_layout.addWidget(btn_export)&#10;        file_layout.addWidget(btn_preprocess)&#10;        file_layout.addWidget(btn_predict)&#10;        param_container_layout.addWidget(file_group)&#10;&#10;        # Baseline Correction group&#10;        baseline_group = QtWidgets.QGroupBox(&quot; Baseline Correction (ALS)&quot;)&#10;        baseline_group.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        baseline_layout = QtWidgets.QVBoxLayout(baseline_group)&#10;&#10;        baseline_label = QtWidgets.QLabel(&quot;ALS Lambda:&quot;)&#10;        baseline_input = QtWidgets.QLineEdit(&quot;100000&quot;)&#10;        baseline_input.setPlaceholderText(&quot;Regularization parameter&quot;)&#10;&#10;        intensity_label = QtWidgets.QLabel(&quot;Target Max Intensity:&quot;)&#10;        intensity_input = QtWidgets.QLineEdit(&quot;0.8&quot;)&#10;        intensity_input.setPlaceholderText(&quot;0.0 - 1.0&quot;)&#10;&#10;        anchor_label = QtWidgets.QLabel(&quot;ALS p:&quot;)&#10;        anchor_input = QtWidgets.QLineEdit(&quot;0.001&quot;)&#10;        anchor_input.setPlaceholderText(&quot;Asymmetry parameter (0-1)&quot;)&#10;&#10;        max_iter_label = QtWidgets.QLabel(&quot;ALS Max Iterations:&quot;)&#10;        max_iter_input = QtWidgets.QLineEdit(&quot;10&quot;)&#10;        max_iter_input.setPlaceholderText(&quot;Number of iterations&quot;)&#10;&#10;        baseline_layout.addWidget(baseline_label)&#10;        baseline_layout.addWidget(baseline_input)&#10;        baseline_layout.addWidget(intensity_label)&#10;        baseline_layout.addWidget(intensity_input)&#10;        baseline_layout.addWidget(anchor_label)&#10;        baseline_layout.addWidget(anchor_input)&#10;        baseline_layout.addWidget(max_iter_label)&#10;        baseline_layout.addWidget(max_iter_input)&#10;        param_container_layout.addWidget(baseline_group)&#10;&#10;        # Prediction Parameters group&#10;        prediction_group = QtWidgets.QGroupBox(&quot; Prediction Parameters&quot;)&#10;        prediction_group.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        prediction_layout = QtWidgets.QVBoxLayout(prediction_group)&#10;&#10;        threshold_label = QtWidgets.QLabel(&quot;Detection Threshold:&quot;)&#10;        threshold_input = QtWidgets.QLineEdit(&quot;0.4&quot;)&#10;        threshold_input.setPlaceholderText(&quot;0.0 - 1.0&quot;)&#10;&#10;        min_height_label = QtWidgets.QLabel(&quot;Min Peak Height:&quot;)&#10;        min_height_input = QtWidgets.QLineEdit(&quot;0.1&quot;)&#10;        min_height_input.setPlaceholderText(&quot;Minimum probability for peak&quot;)&#10;&#10;        min_width_label = QtWidgets.QLabel(&quot;Min Peak Width:&quot;)&#10;        min_width_input = QtWidgets.QLineEdit(&quot;1&quot;)&#10;        min_width_input.setPlaceholderText(&quot;Minimum width in data points&quot;)&#10;&#10;        max_peaks_label = QtWidgets.QLabel(&quot;Max Peaks per Element:&quot;)&#10;        max_peaks_input = QtWidgets.QLineEdit(&quot;3&quot;)&#10;        max_peaks_input.setPlaceholderText(&quot;Maximum number of peaks&quot;)&#10;&#10;        prominence_label = QtWidgets.QLabel(&quot;Peak Prominence:&quot;)&#10;        prominence_input = QtWidgets.QLineEdit(&quot;0.05&quot;)&#10;        prominence_input.setPlaceholderText(&quot;Minimum prominence&quot;)&#10;&#10;        min_distance_label = QtWidgets.QLabel(&quot;Min Peak Distance:&quot;)&#10;        min_distance_input = QtWidgets.QLineEdit(&quot;5&quot;)&#10;        min_distance_input.setPlaceholderText(&quot;Minimum distance between peaks&quot;)&#10;&#10;        self.threshold_input = threshold_input&#10;        self.min_height_input = min_height_input&#10;        self.min_width_input = min_width_input&#10;        self.max_peaks_input = max_peaks_input&#10;        self.prominence_input = prominence_input&#10;        self.min_distance_input = min_distance_input&#10;&#10;        prediction_layout.addWidget(threshold_label)&#10;        prediction_layout.addWidget(threshold_input)&#10;        prediction_layout.addWidget(min_height_label)&#10;        prediction_layout.addWidget(min_height_input)&#10;        prediction_layout.addWidget(min_width_label)&#10;        prediction_layout.addWidget(min_width_input)&#10;        prediction_layout.addWidget(max_peaks_label)&#10;        prediction_layout.addWidget(max_peaks_input)&#10;        prediction_layout.addWidget(prominence_label)&#10;        prediction_layout.addWidget(prominence_input)&#10;        prediction_layout.addWidget(min_distance_label)&#10;        prediction_layout.addWidget(min_distance_input)&#10;        param_container_layout.addWidget(prediction_group)&#10;&#10;        # Wavelength Range group&#10;        wavelength_group = QtWidgets.QGroupBox(&quot; Wavelength Range&quot;)&#10;        wavelength_group.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        wavelength_layout = QtWidgets.QVBoxLayout(wavelength_group)&#10;&#10;        min_wavelength_label = QtWidgets.QLabel(&quot;Min Wavelength (nm):&quot;)&#10;        min_wavelength_input = QtWidgets.QLineEdit(&quot;200&quot;)&#10;        min_wavelength_input.setPlaceholderText(&quot;Minimum wavelength&quot;)&#10;&#10;        max_wavelength_label = QtWidgets.QLabel(&quot;Max Wavelength (nm):&quot;)&#10;        max_wavelength_input = QtWidgets.QLineEdit(&quot;800&quot;)&#10;        max_wavelength_input.setPlaceholderText(&quot;Maximum wavelength&quot;)&#10;&#10;        self.min_wavelength_input = min_wavelength_input&#10;        self.max_wavelength_input = max_wavelength_input&#10;&#10;        wavelength_layout.addWidget(min_wavelength_label)&#10;        wavelength_layout.addWidget(min_wavelength_input)&#10;        wavelength_layout.addWidget(max_wavelength_label)&#10;        wavelength_layout.addWidget(max_wavelength_input)&#10;        param_container_layout.addWidget(wavelength_group)&#10;&#10;        # Results group&#10;        results_group = QtWidgets.QGroupBox(&quot;Results&quot;)&#10;        results_group.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        results_layout = QtWidgets.QVBoxLayout(results_group)&#10;        self.results_label = QtWidgets.QLabel(&quot;Results will appear here after prediction.&quot;)&#10;        results_layout.addWidget(self.results_label)&#10;        param_container_layout.addWidget(results_group)&#10;&#10;        param_container_layout.addStretch()&#10;        param_scroll.setWidget(param_container)&#10;        left_bottom_layout.addWidget(param_scroll)&#10;&#10;        # ========== KUADRAN KANAN BAWAH: FILE LIST &amp; LOG ==========&#10;        right_bottom_panel = QtWidgets.QWidget()&#10;        right_bottom_layout = QtWidgets.QVBoxLayout(right_bottom_panel)&#10;        right_bottom_layout.setContentsMargins(0, 0, 0, 0)&#10;&#10;        # Header&#10;        file_log_header = QtWidgets.QLabel(&quot; Files &amp; Log&quot;)&#10;        file_log_header.setStyleSheet(&quot;font-weight: bold; padding: 5px; background-color: #9b59b6; color: white;&quot;)&#10;        right_bottom_layout.addWidget(file_log_header)&#10;&#10;        # File list table&#10;        file_group_bottom = QtWidgets.QGroupBox(&quot; Loaded Files&quot;)&#10;        file_group_bottom.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        file_table_layout = QtWidgets.QVBoxLayout(file_group_bottom)&#10;&#10;        self.data_table = QtWidgets.QTableWidget(0, 3)&#10;        self.data_table.setHorizontalHeaderLabels([&quot;Filename&quot;, &quot;Intensity&quot;, &quot;Status&quot;])&#10;        self.data_table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)&#10;        self.data_table.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)&#10;        self.data_table.horizontalHeader().setStretchLastSection(True)&#10;        file_table_layout.addWidget(self.data_table)&#10;        right_bottom_layout.addWidget(file_group_bottom, stretch=1)&#10;&#10;        # Log panel&#10;        log_group = QtWidgets.QGroupBox(&quot; Activity Log&quot;)&#10;        log_group.setStyleSheet(&quot;QGroupBox { font-weight: bold; }&quot;)&#10;        log_layout = QtWidgets.QVBoxLayout(log_group)&#10;&#10;        self.log_text = QtWidgets.QTextEdit()&#10;        self.log_text.setReadOnly(True)&#10;        self.log_text.setMaximumHeight(200)&#10;        self.log_text.setStyleSheet(&quot;background-color: #2c3e50; color: #ecf0f1; font-family: 'Courier New';&quot;)&#10;        log_layout.addWidget(self.log_text)&#10;        right_bottom_layout.addWidget(log_group, stretch=1)&#10;&#10;        # ========== ASSIGN KUADRAN KE GRID LAYOUT ==========&#10;        # Grid Layout: (row, col, rowSpan, colSpan)&#10;        main_layout.addWidget(left_top_panel, 0, 0)      # Kiri Atas&#10;        main_layout.addWidget(right_top_panel, 0, 1)     # Kanan Atas&#10;        main_layout.addWidget(left_bottom_panel, 1, 0)   # Kiri Bawah&#10;        main_layout.addWidget(right_bottom_panel, 1, 1)  # Kanan Bawah&#10;&#10;        # Set proporsi yang sama untuk semua kuadran&#10;        main_layout.setRowStretch(0, 1)&#10;        main_layout.setRowStretch(1, 1)&#10;        main_layout.setColumnStretch(0, 1)&#10;        main_layout.setColumnStretch(1, 1)&#10;&#10;        # Connect button signals&#10;        btn_load.clicked.connect(self.load_file)&#10;        btn_load_folder.clicked.connect(self.load_folder)&#10;        btn_preprocess.clicked.connect(self.preprocess_current_file)&#10;        btn_predict.clicked.connect(self.predict_current_file)&#10;        btn_export_plot.clicked.connect(self.export_publication_plot)&#10;        self.data_table.cellClicked.connect(self.on_file_selected)&#10;&#10;        # Menu bar&#10;        menu_bar = self.menuBar()&#10;        file_menu = menu_bar.addMenu(&quot;File&quot;)&#10;        file_menu.addAction(&quot;Open&quot;)&#10;        file_menu.addAction(&quot;Save&quot;)&#10;        file_menu.addSeparator()&#10;        file_menu.addAction(&quot;Exit&quot;, self.close)&#10;        view_menu = menu_bar.addMenu(&quot;View&quot;)&#10;        analysis_menu = menu_bar.addMenu(&quot;Analysis&quot;)&#10;        help_menu = menu_bar.addMenu(&quot;Help&quot;)&#10;        help_menu.addAction(&quot;About&quot;)&#10;&#10;        # Tool bar&#10;        tool_bar = self.addToolBar(&quot;Main Toolbar&quot;)&#10;        tool_bar.addAction(&quot;Load&quot;)&#10;        tool_bar.addAction(&quot;Save&quot;)&#10;        tool_bar.addAction(&quot;Start&quot;)&#10;        tool_bar.addAction(&quot;Stop&quot;)&#10;        self.min_wavelength_input.editingFinished.connect(self.update_region_from_inputs)&#10;        self.max_wavelength_input.editingFinished.connect(self.update_region_from_inputs)&#10;        tool_bar.addAction(&quot;Pan&quot;)&#10;        tool_bar.addAction(&quot;Reset&quot;)&#10;        tool_bar.addSeparator()&#10;        tool_bar.addAction(&quot;Export Plot&quot;)&#10;&#10;        # Status bar&#10;        self.statusBar().showMessage(&quot;Ready | Device: Disconnected | Mode: Idle&quot;)&#10;&#10;        # Initialize variables&#10;        self.loaded_folder = None&#10;        self.file_list = []&#10;        self.current_file = None&#10;        self.preprocessed_spectrum = None&#10;&#10;        # Parameter inputs&#10;        self.threshold_input = threshold_input&#10;        self.baseline_input = baseline_input&#10;        self.intensity_input = intensity_input&#10;        self.anchor_input = anchor_input&#10;        self.max_iter_input = max_iter_input&#10;        self.min_height_input = min_height_input&#10;        self.min_width_input = min_width_input&#10;        self.max_peaks_input = max_peaks_input&#10;        self.prominence_input = prominence_input&#10;        self.min_distance_input = min_distance_input&#10;&#10;        # Assets cache&#10;        self._assets_loaded = False&#10;        self._cached_model = None&#10;        self._cached_element_map = None&#10;        self._cached_target_wavelengths = None&#10;&#10;&#10;    # Helper: ensure assets are loaded once and valid&#10;    def ensure_assets_loaded(self) -&gt; bool:&#10;        &quot;&quot;&quot;Load and cache model/assets once. Returns True on success.&quot;&quot;&quot;&#10;        if self._assets_loaded:&#10;            return True&#10;        try:&#10;            from app.model import load_assets&#10;            assets = load_assets()&#10;            if not isinstance(assets, tuple) or len(assets) != 3:&#10;                self.log_text.append(&quot;load_assets() returned unexpected value — expected (model, element_map, wavelengths)&quot;)&#10;                return False&#10;            model, element_map, target_wavelengths = assets&#10;            # Basic validations&#10;            if not hasattr(model, '__call__'):&#10;                self.log_text.append(f&quot;Loaded model object is not callable: {type(model)}&quot;)&#10;                return False&#10;            if not isinstance(element_map, dict):&#10;                self.log_text.append(f&quot;element_map has unexpected type: {type(element_map)}&quot;)&#10;                return False&#10;            import numpy as _np&#10;            if not isinstance(target_wavelengths, _np.ndarray):&#10;                self.log_text.append(f&quot;target_wavelengths has unexpected type: {type(target_wavelengths)}&quot;)&#10;                return False&#10;&#10;            self._cached_model = model&#10;            self._cached_element_map = element_map&#10;            self._cached_target_wavelengths = target_wavelengths&#10;            self._assets_loaded = True&#10;            self.log_text.append(&quot;Aset model berhasil dimuat dan dicache.&quot;)&#10;            return True&#10;        except Exception as e:&#10;            import traceback&#10;            self.log_text.append(f&quot;Error loading assets: {e}&quot;)&#10;            self.log_text.append(traceback.format_exc())&#10;            return False&#10;&#10;    def load_file(self):&#10;        file_dialog = QtWidgets.QFileDialog(self, &quot;Open Data File&quot;, &quot;&quot;, &quot;Data Files (*.asc *.txt *.csv);;All Files (*)&quot;)&#10;        if file_dialog.exec():&#10;            file_path = file_dialog.selectedFiles()[0]&#10;            try:&#10;                with open(file_path, 'r') as f:&#10;                    content = f.read()&#10;                self.log_text.append(f&quot;Loaded file: {file_path}\n---\n{content[:1000]}\n---&quot;)&#10;            except Exception as e:&#10;                self.log_text.append(f&quot;Error loading file: {e}&quot;)&#10;&#10;    def load_folder(self):&#10;        folder = QtWidgets.QFileDialog.getExistingDirectory(self, &quot;Select Folder with ASC Files&quot;)&#10;        if folder:&#10;            import os&#10;            self.loaded_folder = folder&#10;            self.file_list = [f for f in os.listdir(folder) if f.lower().endswith('.asc')]&#10;            self.data_table.setRowCount(len(self.file_list))&#10;            for i, fname in enumerate(self.file_list):&#10;                self.data_table.setItem(i, 0, QtWidgets.QTableWidgetItem(fname))&#10;                self.data_table.setItem(i, 1, QtWidgets.QTableWidgetItem(&quot;-&quot;))&#10;                self.data_table.setItem(i, 2, QtWidgets.QTableWidgetItem(&quot;-&quot;))&#10;            self.log_text.append(f&quot;Loaded folder: {folder} ({len(self.file_list)} .asc files)&quot;)&#10;            if not self.file_list:&#10;                self.log_text.append(&quot;No .asc files found in the selected folder.&quot;)&#10;&#10;    def on_file_selected(self, row, col):&#10;        if not self.file_list or row &gt;= len(self.file_list):&#10;            self.log_text.append(&quot;No file selected or out of range.&quot;)&#10;            return&#10;        fname = self.file_list[row]&#10;        self.current_file = fname&#10;        import os&#10;        fpath = os.path.join(self.loaded_folder, fname)&#10;        try:&#10;            with open(fpath, 'r') as f:&#10;                lines = f.readlines()&#10;            # Parse ASC: cari dua kolom float&#10;            import numpy as np&#10;            data = []&#10;            for line in lines:&#10;                if line.strip() and not line.startswith('#'):&#10;                    parts = line.split()&#10;                    if len(parts) &gt;= 2:&#10;                        try:&#10;                            wl, inten = float(parts[0]), float(parts[1])&#10;                            data.append((wl, inten))&#10;                        except Exception:&#10;                            continue&#10;            if data:&#10;                arr = np.array(data)&#10;                self.plot_widget.clear()&#10;                self.plot_widget.plot(arr[:,0], arr[:,1], pen='b')&#10;                # Update kolom intensity (max) di tabel&#10;                max_inten = str(np.max(arr[:,1]))&#10;                self.data_table.setItem(row, 1, QtWidgets.QTableWidgetItem(max_inten))&#10;                self.log_text.append(f&quot;Plotted: {fname}&quot;)&#10;            else:&#10;                self.plot_widget.clear()&#10;                self.data_table.setItem(row, 1, QtWidgets.QTableWidgetItem(&quot;-&quot;))&#10;                self.log_text.append(f&quot;No valid data in: {fname}&quot;)&#10;        except Exception as e:&#10;            self.plot_widget.clear()&#10;            self.log_text.append(f&quot;Error reading {fname}: {e}&quot;)&#10;&#10;    def preprocess_current_file(self):&#10;        if not self.current_file or not self.loaded_folder:&#10;            self.log_text.append(&quot;No file selected for preprocessing.&quot;)&#10;            return&#10;        import os&#10;        import numpy as np&#10;        from app.processing import prepare_asc_data&#10;        try:&#10;            ok = self.ensure_assets_loaded()&#10;            if not ok:&#10;                self.log_text.append(&quot;Cannot preprocess because assets failed to load.&quot;)&#10;                return&#10;            model = self._cached_model&#10;            element_map = self._cached_element_map&#10;            target_wavelengths = self._cached_target_wavelengths&#10;        except Exception as e:&#10;            self.log_text.append(f&quot;Error loading assets: {e}&quot;)&#10;            return&#10;&#10;        fpath = os.path.join(self.loaded_folder, self.current_file)&#10;        try:&#10;            with open(fpath, 'r') as f:&#10;                content = f.read()&#10;            # Get parameters from inputs&#10;            try:&#10;                als_lambda = float(self.baseline_input.text())&#10;                target_max_intensity = float(self.intensity_input.text())&#10;                als_p = float(self.anchor_input.text())&#10;                als_max_iter = int(self.max_iter_input.text())&#10;            except ValueError:&#10;                self.log_text.append(&quot;Invalid input for ALS parameters. Using defaults.&quot;)&#10;                als_lambda = 1e5&#10;                target_max_intensity = 0.8&#10;                als_p = 0.001&#10;                als_max_iter = 10&#10;            self.preprocessed_spectrum = prepare_asc_data(content, target_wavelengths, target_max_intensity, als_lambda, als_p, als_max_iter)&#10;            self.plot_widget.clear()&#10;            self.plot_widget.plot(target_wavelengths, self.preprocessed_spectrum, pen='g')&#10;            # Update note di tabel&#10;            row = self.file_list.index(self.current_file)&#10;            self.data_table.setItem(row, 2, QtWidgets.QTableWidgetItem(&quot;Preprocessed&quot;))&#10;            self.log_text.append(f&quot;Preprocessed: {self.current_file}&quot;)&#10;        except Exception as e:&#10;            self.log_text.append(f&quot;Error preprocessing {self.current_file}: {e}&quot;)&#10;            import traceback&#10;            self.log_text.append(f&quot;Traceback: {traceback.format_exc()}&quot;)&#10;&#10;    def predict_current_file(self):&#10;        if self.preprocessed_spectrum is None:&#10;            self.log_text.append(&quot;No preprocessed spectrum to predict. Please preprocess first.&quot;)&#10;            return&#10;        try:&#10;            ok = self.ensure_assets_loaded()&#10;            if not ok:&#10;                self.log_text.append(&quot;Cannot predict because assets failed to load.&quot;)&#10;                return&#10;            model = self._cached_model&#10;            element_map = self._cached_element_map&#10;            target_wavelengths = self._cached_target_wavelengths&#10;&#10;            from app.model import predict_with_spatial_info&#10;&#10;            self.log_text.append(f&quot;Running prediction with spatial information...&quot;)&#10;&#10;            # Dapatkan prediksi global DAN spasial (per-wavelength)&#10;            global_pred, spatial_pred = predict_with_spatial_info(model, self.preprocessed_spectrum)&#10;&#10;            self.log_text.append(f&quot;Global prediction shape: {global_pred.shape}&quot;)&#10;            self.log_text.append(f&quot;Spatial prediction shape: {spatial_pred.shape}&quot;)&#10;            self.log_text.append(f&quot;Global pred range: [{global_pred.min():.3f}, {global_pred.max():.3f}]&quot;)&#10;&#10;            # Format hasil prediksi dengan nama elemen&#10;            element_names = list(element_map.keys())&#10;            result_text = &quot;Predicted Elements (probability &gt; 0.05):\n&quot;&#10;            result_text += &quot;=&quot; * 40 + &quot;\n&quot;&#10;            detected_elements = []&#10;&#10;            # Ambil semua elemen dengan threshold rendah&#10;            threshold = 0.05&#10;            for element, probability in zip(element_names, global_pred):&#10;                if probability &gt; threshold:&#10;                    detected_elements.append((element, float(probability)))&#10;&#10;            # Sort berdasarkan probability&#10;            detected_elements.sort(key=lambda x: x[1], reverse=True)&#10;&#10;            # Jika tidak ada yang terdeteksi, tampilkan top 10&#10;            if not detected_elements:&#10;                sorted_pred = sorted(zip(element_names, global_pred), key=lambda x: x[1], reverse=True)&#10;                result_text = &quot;Top 10 Predicted Elements:\n&quot;&#10;                result_text += &quot;=&quot; * 40 + &quot;\n&quot;&#10;                for element, probability in sorted_pred[:10]:&#10;                    result_text += f&quot;{element:&gt;6s}: {probability:.4f} ({probability*100:.2f}%)\n&quot;&#10;                    detected_elements.append((element, float(probability)))&#10;            else:&#10;                for element, probability in detected_elements:&#10;                    result_text += f&quot;{element:&gt;6s}: {probability:.4f} ({probability*100:.2f}%)\n&quot;&#10;&#10;            result_text += &quot;=&quot; * 40 + &quot;\n&quot;&#10;            result_text += f&quot;Total detected: {len(detected_elements)} elements&quot;&#10;&#10;            self.results_label.setText(result_text)&#10;            self.results_label.setWordWrap(True)&#10;&#10;            # Plot spektrum dengan label elemen MENGGUNAKAN SPATIAL PREDICTION&#10;            self.plot_spectrum_with_labels(&#10;                target_wavelengths,&#10;                self.preprocessed_spectrum,&#10;                detected_elements,&#10;                element_map,&#10;                spatial_pred  # Pass spatial prediction data&#10;            )&#10;&#10;            # Update note di tabel&#10;            if self.current_file in self.file_list:&#10;                row = self.file_list.index(self.current_file)&#10;                self.data_table.setItem(row, 2, QtWidgets.QTableWidgetItem(&quot;Predicted&quot;))&#10;&#10;            self.log_text.append(f&quot;✓ Prediction completed for: {self.current_file}&quot;)&#10;            self.log_text.append(f&quot;✓ Found {len(detected_elements)} potential elements&quot;)&#10;&#10;        except Exception as e:&#10;            self.log_text.append(f&quot;Error during prediction: {e}&quot;)&#10;            import traceback&#10;            self.log_text.append(f&quot;Traceback:\n{traceback.format_exc()}&quot;)&#10;&#10;    def plot_spectrum_with_labels(self, wavelengths, spectrum, detected_elements, element_map, spatial_pred=None):&#10;        &quot;&quot;&quot;Plot spektrum dengan region selector interaktif, label detail hanya di plot preview&quot;&quot;&quot;&#10;        if detected_elements is None or len(detected_elements) == 0:&#10;            self.log_text.append(&quot;No elements to label on spectrum&quot;)&#10;            return&#10;&#10;        try:&#10;            # Clear both plots&#10;            self.plot_widget.clear()&#10;            self.detail_plot_widget.clear()&#10;&#10;            # Warna untuk setiap elemen&#10;            colors = [&#10;                (255, 0, 0), (255, 102, 0), (255, 170, 0), (255, 215, 0), (0, 255, 0),&#10;                (0, 255, 255), (0, 136, 255), (0, 0, 255), (136, 0, 255), (255, 0, 255)&#10;            ]&#10;&#10;            element_names = list(element_map.keys())&#10;&#10;            if spatial_pred is not None:&#10;                self.log_text.append(&quot;Setting up interactive region selector...&quot;)&#10;&#10;                # Store data untuk digunakan saat region berubah&#10;                self.wavelengths = wavelengths&#10;                self.spectrum = spectrum&#10;                self.detected_elements = detected_elements&#10;                self.spatial_pred = spatial_pred&#10;                self.element_names = element_names&#10;                self.colors = colors&#10;&#10;                # ========== PLOT UTAMA: Spektrum + Region Selector (TANPA LABEL) ==========&#10;                self.plot_widget.plot(wavelengths, spectrum, pen=pg.mkPen(color=(100, 255, 100), width=2), name='Spectrum')&#10;&#10;                # Tambahkan LinearRegionItem untuk memilih region&#10;                # Default region: tengah spektrum ±100nm&#10;                wl_min, wl_max = wavelengths[0], wavelengths[-1]&#10;                wl_center = (wl_min + wl_max) / 2&#10;                # Try to use input values for initial region&#10;                try:&#10;                    input_min = float(self.min_wavelength_input.text())&#10;                    input_max = float(self.max_wavelength_input.text())&#10;                    if input_min &lt; input_max and wl_min &lt;= input_min &lt;= wl_max and wl_min &lt;= input_max &lt;= wl_max:&#10;                        initial_region = (input_min, input_max)&#10;                    else:&#10;                        initial_region = (wl_center - 50, wl_center + 50)&#10;                except ValueError:&#10;                    initial_region = (wl_center - 50, wl_center + 50)&#10;&#10;                self.region_selector = pg.LinearRegionItem(&#10;                    values=initial_region,&#10;                    brush=pg.mkBrush(100, 100, 200, 50),  # Semi-transparent blue&#10;                    pen=pg.mkPen(color=(100, 100, 255), width=2)&#10;                )&#10;                self.plot_widget.addItem(self.region_selector)&#10;&#10;                # Connect signal untuk update saat region berubah&#10;                self.region_selector.sigRegionChanged.connect(self.update_detail_plot)&#10;&#10;                # Setup main plot&#10;                self.plot_widget.setLabel('left', 'Normalized Intensity', **{'font-size': '12pt'})&#10;                self.plot_widget.setLabel('bottom', 'Wavelength (nm)', **{'font-size': '12pt'})&#10;                self.plot_widget.setTitle(&#10;                    'Full Spectrum (Drag the region selector to view details)',&#10;                    **{'font-size': '13pt', 'color': '#333'}&#10;                )&#10;                self.plot_widget.showGrid(x=True, y=True, alpha=0.3)&#10;&#10;                # Initial update untuk plot detail&#10;                self.update_detail_plot()&#10;&#10;                # Log info&#10;                self.log_text.append(f&quot;✓ Interactive region selector ready&quot;)&#10;                self.log_text.append(f&quot;✓ Drag the blue region on main plot to see details&quot;)&#10;                self.log_text.append(f&quot;✓ Detail plot will show labels for selected wavelength range&quot;)&#10;&#10;            else:&#10;                # Fallback&#10;                self.log_text.append(&quot;No spatial prediction available&quot;)&#10;                self.plot_widget.plot(wavelengths, spectrum, pen='g')&#10;                self.plot_widget.setTitle('Preprocessed Spectrum')&#10;&#10;        except Exception as e:&#10;            self.log_text.append(f&quot;Error plotting spectrum: {e}&quot;)&#10;            self.log_text.append(traceback.format_exc())&#10;&#10;    def update_detail_plot(self):&#10;        &quot;&quot;&quot;Update plot detail berdasarkan region yang dipilih di plot utama&quot;&quot;&quot;&#10;        try:&#10;            # Get peak parameters from inputs&#10;            try:&#10;                detection_threshold = float(self.threshold_input.text())&#10;                min_height = float(self.min_height_input.text())&#10;                min_width = float(self.min_width_input.text())&#10;                max_peaks = int(self.max_peaks_input.text())&#10;                prominence = float(self.prominence_input.text())&#10;                min_distance = float(self.min_distance_input.text())&#10;            except ValueError:&#10;                self.log_text.append(&quot;Invalid peak parameters. Using defaults.&quot;)&#10;                detection_threshold = 0.4&#10;                min_height = 0.1&#10;                min_width = 1&#10;                max_peaks = 3&#10;                prominence = 0.05&#10;                min_distance = 5&#10;&#10;            # Get selected region&#10;            region_range = self.region_selector.getRegion()&#10;            wl_start, wl_end = region_range&#10;&#10;            # Find indices dalam range&#10;            mask = (self.wavelengths &gt;= wl_start) &amp; (self.wavelengths &lt;= wl_end)&#10;            indices = np.where(mask)[0]&#10;&#10;            if len(indices) == 0:&#10;                return&#10;&#10;            # Extract data untuk region ini&#10;            wl_region = self.wavelengths[indices]&#10;            spectrum_region = self.spectrum[indices]&#10;            spatial_pred_region = self.spatial_pred[indices, :]&#10;&#10;            # Detect peaks in the spectrum region&#10;            peaks, properties = signal.find_peaks(&#10;                spectrum_region,&#10;                height=min_height,&#10;                width=min_width,&#10;                prominence=prominence,&#10;                distance=min_distance&#10;            )&#10;&#10;            # Limit to max_peaks if specified&#10;            if len(peaks) &gt; max_peaks:&#10;                # Sort by prominence and take top max_peaks&#10;                sorted_peaks = sorted(zip(peaks, properties['prominences']), key=lambda x: x[1], reverse=True)[:max_peaks]&#10;                peaks = [p[0] for p in sorted_peaks]&#10;&#10;            # Clear detail plot&#10;            self.detail_plot_widget.clear()&#10;&#10;            # Plot spektrum di region&#10;            self.detail_plot_widget.plot(&#10;                wl_region, spectrum_region,&#10;                pen=pg.mkPen(color=(100, 255, 100), width=2.5),&#10;                name='Spectrum'&#10;            )&#10;&#10;            # Label peaks with detected elements&#10;            all_labels = []&#10;            for peak_idx in peaks:&#10;                wl = wl_region[peak_idx]&#10;                intensity = spectrum_region[peak_idx]&#10;&#10;                # Find the element with highest probability around this peak (within ±5 points)&#10;                best_elem = None&#10;                best_prob = 0&#10;                best_color = None&#10;                start_idx = max(0, peak_idx - 5)&#10;                end_idx = min(len(spatial_pred_region), peak_idx + 6)&#10;                for elem, global_prob in self.detected_elements[:10]:&#10;                    elem_idx = self.element_names.index(elem)&#10;                    prob_region = spatial_pred_region[start_idx:end_idx, elem_idx]&#10;                    max_prob = np.max(prob_region)&#10;                    if max_prob &gt; best_prob and max_prob &gt; detection_threshold:&#10;                        best_prob = max_prob&#10;                        best_elem = elem&#10;                        best_color = self.colors[elem_idx % len(self.colors)]&#10;&#10;                if best_elem:&#10;                    # Add scatter at peak&#10;                    scatter = pg.ScatterPlotItem(&#10;                        [wl], [intensity],&#10;                        pen=pg.mkPen(color=best_color, width=2),&#10;                        brush=pg.mkBrush(*best_color),&#10;                        size=12,&#10;                        symbol='o'&#10;                    )&#10;                    self.detail_plot_widget.addItem(scatter)&#10;&#10;                    # Add label&#10;                    text_label = f&quot;{best_elem}:{best_prob:.1%}\n{wl:.1f}nm&quot;&#10;                    text = pg.TextItem(&#10;                        text=text_label,&#10;                        color=best_color,&#10;                        anchor=(0.5, 1.5),&#10;                        border=pg.mkPen(color=best_color, width=1),&#10;                        fill=pg.mkBrush(0, 0, 0, 150)&#10;                    )&#10;                    text.setPos(wl, intensity)&#10;                    self.detail_plot_widget.addItem(text)&#10;&#10;                    all_labels.append(f&quot;@{wl:.1f}nm: {best_elem}&quot;)&#10;&#10;            # Setup detail plot&#10;            self.detail_plot_widget.setLabel('left', 'Intensity', **{'font-size': '10pt'})&#10;            self.detail_plot_widget.setLabel('bottom', 'Wavelength (nm)', **{'font-size': '10pt'})&#10;            self.detail_plot_widget.setTitle(&#10;                f'Detail View ({wl_start:.1f} - {wl_end:.1f} nm) - {len(all_labels)} peaks labeled',&#10;                **{'font-size': '11pt'}&#10;            )&#10;            self.detail_plot_widget.showGrid(x=True, y=True, alpha=0.3)&#10;&#10;            # Auto-range untuk region yang dipilih&#10;            self.detail_plot_widget.setXRange(wl_start, wl_end, padding=0.02)&#10;&#10;        except Exception as e:&#10;            self.log_text.append(f&quot;Error updating detail plot: {e}&quot;)&#10;            import traceback&#10;            self.log_text.append(f&quot;Traceback:\n{traceback.format_exc()}&quot;)&#10;&#10;    def update_region_from_inputs(self):&#10;        &quot;&quot;&quot;Update the region selector based on min and max wavelength inputs&quot;&quot;&quot;&#10;        try:&#10;            min_wl = float(self.min_wavelength_input.text())&#10;            max_wl = float(self.max_wavelength_input.text())&#10;            if hasattr(self, 'region_selector'):&#10;                self.region_selector.setRegion((min_wl, max_wl))&#10;        except ValueError:&#10;            pass  # Ignore invalid input&#10;&#10;    def export_publication_plot(self):&#10;        &quot;&quot;&quot;Export the current detail plot (preview) with element labels as a publication-ready scientific figure&quot;&quot;&quot;&#10;        try:&#10;            # Check if we have spectrum data and region selector&#10;            if not hasattr(self, 'wavelengths') or not hasattr(self, 'spectrum') or not hasattr(self, 'region_selector'):&#10;                self.log_text.append(&quot;No spectrum data or region selector available for export. Please load, process a file, and select a region first.&quot;)&#10;                return&#10;&#10;            # Get current region&#10;            region_range = self.region_selector.getRegion()&#10;            wl_start, wl_end = region_range&#10;&#10;            # Find indices in range&#10;            mask = (self.wavelengths &gt;= wl_start) &amp; (self.wavelengths &lt;= wl_end)&#10;            indices = np.where(mask)[0]&#10;&#10;            if len(indices) == 0:&#10;                self.log_text.append(&quot;No data in selected region for export.&quot;)&#10;                return&#10;&#10;            # Extract data for region&#10;            wl_region = self.wavelengths[indices]&#10;            spectrum_region = self.spectrum[indices]&#10;            spatial_pred_region = self.spatial_pred[indices, :]&#10;&#10;            # Create matplotlib figure with publication style&#10;            plt.style.use('seaborn-v0_8-paper')  # Use a clean style&#10;            fig, ax = plt.subplots(figsize=(12, 8), dpi=300)&#10;&#10;            # Plot the spectrum region&#10;            ax.plot(wl_region, spectrum_region, color='black', linewidth=1.0)&#10;&#10;            # Get detection threshold and peak parameters&#10;            try:&#10;                detection_threshold = float(self.threshold_input.text())&#10;                min_height = float(self.min_height_input.text())&#10;                min_width = float(self.min_width_input.text())&#10;                max_peaks = int(self.max_peaks_input.text())&#10;                prominence = float(self.prominence_input.text())&#10;                min_distance = float(self.min_distance_input.text())&#10;            except ValueError:&#10;                detection_threshold = 0.4&#10;                min_height = 0.1&#10;                min_width = 1&#10;                max_peaks = 3&#10;                prominence = 0.05&#10;                min_distance = 5&#10;&#10;            # Detect peaks in the spectrum region&#10;            peaks, properties = signal.find_peaks(&#10;                spectrum_region,&#10;                height=min_height,&#10;                width=min_width,&#10;                prominence=prominence,&#10;                distance=min_distance&#10;            )&#10;&#10;            # Limit to max_peaks&#10;            if len(peaks) &gt; max_peaks:&#10;                sorted_peaks = sorted(zip(peaks, properties['prominences']), key=lambda x: x[1], reverse=True)[:max_peaks]&#10;                peaks = [p[0] for p in sorted_peaks]&#10;&#10;            # Add detected elements annotations at peaks&#10;            colors = [&#10;                (255, 0, 0), (255, 102, 0), (255, 170, 0), (255, 215, 0), (0, 255, 0),&#10;                (0, 255, 255), (0, 136, 255), (0, 0, 255), (136, 0, 255), (255, 0, 255)&#10;            ]&#10;&#10;            for peak_idx in peaks:&#10;                wl = wl_region[peak_idx]&#10;                intensity = spectrum_region[peak_idx]&#10;&#10;                # Find the element with highest probability around this peak&#10;                best_elem = None&#10;                best_prob = 0&#10;                best_color = None&#10;                start_idx = max(0, peak_idx - 5)&#10;                end_idx = min(len(spatial_pred_region), peak_idx + 6)&#10;                for elem, global_prob in self.detected_elements[:10]:&#10;                    elem_idx = self.element_names.index(elem)&#10;                    prob_region = spatial_pred_region[start_idx:end_idx, elem_idx]&#10;                    max_prob = np.max(prob_region)&#10;                    if max_prob &gt; best_prob and max_prob &gt; detection_threshold:&#10;                        best_prob = max_prob&#10;                        best_elem = elem&#10;                        best_color = colors[elem_idx % len(colors)]&#10;&#10;                if best_elem:&#10;                    ax.scatter(wl, intensity, color=np.array(best_color)/255, s=60, zorder=5, edgecolors='black', linewidth=0.5)&#10;&#10;                    # Create annotation text&#10;                    text_label = f&quot;{best_elem}:{best_prob:.1%}\n{wl:.1f}nm&quot;&#10;&#10;                    # Position annotation above the point&#10;                    ax.annotate(text_label,&#10;                              xy=(wl, intensity),&#10;                              xytext=(5, 20),&#10;                              textcoords='offset points',&#10;                              bbox=dict(boxstyle='round,pad=0.3', facecolor='white', alpha=0.9, edgecolor='gray'),&#10;                              fontsize=9, ha='left', va='bottom',&#10;                              arrowprops=dict(arrowstyle='-&gt;', color='gray', alpha=0.7))&#10;&#10;            # Customize plot for publication&#10;            ax.set_xlabel('Wavelength (nm)', fontsize=14, fontweight='bold')&#10;            ax.set_ylabel('Normalized Intensity', fontsize=14, fontweight='bold')&#10;            ax.grid(True, alpha=0.3)&#10;            ax.tick_params(axis='both', which='major', labelsize=12)&#10;            ax.set_xlim(wl_start, wl_end)&#10;&#10;            # Add file info&#10;            if self.current_file:&#10;                ax.text(0.02, 0.98, f'File: {self.current_file}\nRegion: {wl_start:.1f} - {wl_end:.1f} nm',&#10;                       transform=ax.transAxes, fontsize=10, verticalalignment='top',&#10;                       bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.7))&#10;&#10;            plt.tight_layout()&#10;&#10;            # Save dialog&#10;            file_path, _ = QtWidgets.QFileDialog.getSaveFileName(self, &quot;Save Publication Plot&quot;, &quot;&quot;, &quot;PNG Files (*.png);;PDF Files (*.pdf);;SVG Files (*.svg)&quot;)&#10;            if file_path:&#10;                import os&#10;                if os.path.isdir(file_path):&#10;                    self.log_text.append(&quot;Selected path is a directory. Please select a valid file name.&quot;)&#10;                    plt.close(fig)&#10;                    return&#10;                # Determine format from extension&#10;                if file_path.lower().endswith('.pdf'):&#10;                    plt.savefig(file_path, format='pdf', bbox_inches='tight', dpi=300)&#10;                elif file_path.lower().endswith('.svg'):&#10;                    plt.savefig(file_path, format='svg', bbox_inches='tight')&#10;                else:&#10;                    plt.savefig(file_path, format='png', bbox_inches='tight', dpi=300)&#10;&#10;                self.log_text.append(f&quot;✓ Publication plot exported to: {file_path}&quot;)&#10;            else:&#10;                self.log_text.append(&quot;Export cancelled.&quot;)&#10;&#10;            plt.close(fig)  # Close the figure to free memory&#10;&#10;        except Exception as e:&#10;            self.log_text.append(f&quot;Error exporting publication plot: {e}&quot;)&#10;            import traceback&#10;            self.log_text.append(f&quot;Traceback:\n{traceback.format_exc()}&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>